
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Blog Of Peng Fei</title>
  <meta name="author" content="Peng Fei">

  
  <meta name="description" content="hello, world 折腾一晚上 octopress 终于有点成效了！
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://airpfei.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Blog Of Peng Fei" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-25271760-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Blog Of Peng Fei</a></h1>
  
    <h2>A blogging framework for hackers</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:airpfei.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/05/12/hello-world/">Hello, World</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-05-12T02:47:00+08:00" pubdate data-updated="true">May 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>hello, world</p>

<p>折腾一晚上 octopress 终于有点成效了！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/15/plan/">Read Some Source Code in the Next Few Months</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-15T00:00:00+08:00" pubdate data-updated="true">Mar 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>modern c++ design let me know c++ template can do much more, although i can&#8217;t complete understand. i need read it again.</p>

<p>loki, chrome, linux kernel i really want to read.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/10/goodbye-c-sharp/">Goodbye C Sharp</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-10T00:00:00+08:00" pubdate data-updated="true">Dec 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><span style="display:block;text-indent:2em;">公司一款产品的最后的一个版本即将发布，以后在这款产品上只是一些例行的维护，不会再有什么重大的变化。这是一套以.net框架为基础的产品，由于性能问题，ui的掌控的问题使得公司最终放弃.net框架。</span>
<span style="display:block;text-indent:2em;">我从2009年8月开始接触.net，一边学习，一边实践。经过2年C#编程，也对C#及.net框架有一些了解。先先说一下有点吧，那就是简单。.net把对字符串、Window、network的操作变得非常简单。但是由于.net的封装，使得一些底层的操作非常困难。例如，给Window设置一个Class，至今我还不知道如何设置。又如WinForm原生控件的定制性很差，不能满足一些常用的需求，有时必须使用Win32Api来完成。还有就是.net本身的性能问题，使得很多商业软件放弃使用。</span>
<span style="display:block;text-indent:2em;">当然，在这两年里，也接触了一些.net框架中比较新的东西，如WPF。不得不承认WPF把UI实现变得很容易。但WPF对设备性能的要求，对.net版本的要求使得许多商业软件放弃使用。要知道在Win xp占有率达到75%的天朝，.net3.5是多么遥不可及！</span>
<span style="display:block;text-indent:2em;">对一些企业内部的管理软件，.net还是很适合的，节约开发成本。如果开发者对Windows的内存没有很好的掌控力，使用C/C++有可能适得其反。.net的GC使得开发者不用花很多精力放在内存管理上。觉得WinPhone可能会让C#上升到一个新的高度</span>
<span style="display:block;text-indent:2em;">感觉silverlight的死期不远了，html5使得silverlight没有什么存在的价值了。</span>
<span style="display:block;text-indent:2em;">即将告别C#投向C++阵营，还是很感谢C#的，毕竟之前我是用它混饭的。一直很想使用C++编程，因为这是一门公认的复杂语言，也应为我能更近距离的接触操作系统。</span>
<span style="display:block;text-indent:2em;">白天折腾了很久mp4box，学习到一点C++的调试技巧。在link错误时，编译器表错为<em>function not found，开始以为</em>function是函数名，结果搜了半天没找到，最后才发现“_”不是函数名的一部分。</span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/12/09/learn-windows-progamme-8/">Windows via C/c++ 笔记 （八）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-12-09T00:00:00+08:00" pubdate data-updated="true">Dec 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>第19章 DLL基础</h2>


<p><span style="display:block;text-indent:2em;">一般在dll中分配的内存，都需要通过dll释放</span>
<span style="display:block;text-indent:2em;">DLL若连接的是静态版本，那么DLL的代码里面就会有一份free和malloc的代码，若EXE也使用的是静态版本的C/C++运行库，那么也会有另一份代码。当然你使用DLL代码里申请的内存不能在EXE的free代码中释放。原因是因为有两个不通的堆管理，在EXE中查不到相应申请的内存，自然释放会失败。</span>
<span style="display:block;text-indent:2em;">导出函数或变量，链接器生成lib文件。</span>
<span style="display:block;text-indent:2em;">dumpbin -exports *.dll</span>
<span style="display:block;text-indent:2em;">dumpbin -imports *.exe</span>
<span style="display:block;text-indent:2em;">避免MS VC++的名字粉碎(Name Mangling)：.def文件EXPORTS段导出函数名；extern &#8220;C&#8221;；#pragma comment (linker, &#8220;/export:MyFunc=_MyFunc@8&#8221;)</span>
<span style="display:block;text-indent:2em;">导入：__declspec(dllimport)或使用extern</span>
<span style="display:block;text-indent:2em;">运行可执行模块：操作系统加载程序为进程创建虚拟地址空间，把可执行模块映射到进程的地址空间中。之后加载程序会检查可执行模块的导入段(不同版本的dll可能在这个步骤出问题)，对所需的DLL进行定位并将其映射到进程的地址空间中。</span>
<span style="display:block;text-indent:2em;">基址重定位和绑定可以加快应用程序初始化速度。</span></p>

<h2>第20章 DLL高级技术</h2>


<p><span style="display:block;text-indent:2em;">LoadLibrary(Ex)、FreeLibrary、FreeLibraryAndExitThread、GetModuleHandle、GetModuleFileName</span>
<span style="display:block;text-indent:2em;">GetProcAddress</span>
<span style="display:block;text-indent:2em;">DllMain的序列化调用。DisableThreadLibraryCalls</span>
<span style="display:block;text-indent:2em;">延迟载入DLL：当我们的代码试图引用DLL包含的符号时载入DLL。加快初始化速度；解决老版本DLL没有一些函数的问题。</span>
<span style="display:block;text-indent:2em;">一个导出全局变量的DLL、Kernel32.dll无法延迟加载。不应在DllMain中调用延迟加载的函数。</span>
<span style="display:block;text-indent:2em;">VcppException延迟载入DLL异常处理，DelayLoadInfo</span>
<span style="display:block;text-indent:2em;">函数转发器：#pragma comment (linker, &#8220;/export:SomeFunc=Dllwork.SomeOtherFunc&#8221;)</span>
<span style="display:block;text-indent:2em;">模块的基地址重定位，显著提高整个系统的性能。/FIXED不包含重定位段。</span>
<span style="display:block;text-indent:2em;">模块的绑定，提高性能，不必再对模块重新定位，不必查看导入函数的虚拟地址。</span></p>

<h2>第21章 线程局部存储区</h2>


<p><span style="display:block;text-indent:2em;">动态TSL：TlsAlloc、TlsSetValue、TlsGetValue、TlsFree</span>
<span style="display:block;text-indent:2em;">静态TLS：__declspec(thread)</span></p>

<h2>第22章 DLL注入和API拦截</h2>


<p><span style="display:block;text-indent:2em;"><a href="http://www.codeproject.com/KB/system/inject2it.aspx" target="_blank">Demo</a></span>
<span style="display:block;text-indent:2em;">SetWindowLongPtr。从根本上将，DLL注入是目标进程中的一个线程调用LoadLibrary载入我们想要的DLL。</span>
<span style="display:block;text-indent:2em;">使用注册表注入DLL：只会映射到使用Use32.dll的进程中</span>
<span style="display:block;text-indent:2em;">使用Windows挂钩注入DLL：SetWindowsHookEx、UnhookWindowsHookEx。使用PostThreadMessage线程同步。</span>
<span style="display:block;text-indent:2em;">使用远程线程注入DLL：CreateRemoteThread、VirtualAllocEx、VirtualFreeEx、ReadProcessMemory、WriteProcessMemory</span></p>

<h2>结构化异常处理</h2>


<p><span style="display:block;text-indent:2em;"><strong>try中使用return、goto、longjump，</strong>finally中的代码也会被执行。</span>
<span style="display:block;text-indent:2em;"><strong>try, </strong>finally 框架会使finally中的代码执行</span>
<span style="display:block;text-indent:2em;">__leave关键字会使执行代码跳转到try块的结尾。</span></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/30/learn-windows-progamme-7/">Windows via C/c++ 笔记 （七）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-30T00:00:00+08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>第13章 Windows内存体系结构</h2>


<p><span style="display:block;text-indent:2em;">need reread</span>
<span style="display:block;text-indent:2em;">空指针赋值分区、用户模式分区、64KB禁入分区、内核模式分区</span>
<span style="display:block;text-indent:2em;">32位App运行在64位Windows分配的0x00000000&#8217;7FFFFFFF以下的地址空间，64位App默认在0x00000000&#8217;80000000以上的地址空间</span>
<span style="display:block;text-indent:2em;">系统会确保VirtualAlloc预订的地址区域的起始地址是分配粒度(allocation granularity)的整数倍</span>
<span style="display:block;text-indent:2em;">一个块是一些连续的页面</span></p>

<h2>第14章 探索虚拟内存</h2>


<p><span style="display:block;text-indent:2em;">系统信息：GetSystemInfo、GetLogicalProcessorInformation、IsWow64Process、GetCurrentProcess</span>
<span style="display:block;text-indent:2em;">虚拟内存状态：GlobalMemoryStatus(Ex)</span>
<span style="display:block;text-indent:2em;">NUMA机器中的内存管理：GetNumaAvailableMemoryNode、GetNumaProcessNode、GetNumaHighestNodeNumber、GetNumaNodeProcessorMask</span>
地址空间的状态：VirtualQuery(Ex)
<span style="display:block;text-indent:2em;">/dynamicbase  进程共享ASLR基址重定向的页面</span></p>

<h2>第15章 在应用程序中使用虚拟内存</h2>


<p><span style="display:block;text-indent:2em;">虚拟内存：管理大型对象数组或大型数据结构数组</span>
<span style="display:block;text-indent:2em;">内存映射文件：管理大型数据流，多进程共享数据</span>
<span style="display:block;text-indent:2em;">堆：管理大量小型对象</span>
<span style="display:block;text-indent:2em;">VirtualAlloc、VirtualFree、VirtualQuery、VirtualProtect</span>
地址窗口扩展(AWE)(使用物理内存，提高性能)：AllocateUserPhysicalPages、MapUserPhysicalPages、FreeUserPhysicalPages</p>

<h2>第16章 线程栈</h2>


<p><span style="display:block;text-indent:2em;">SetThreadStackGuarante</span></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/30/learn-windows-progamme-7/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/24/learn-windows-progamme-6/">Windows via C/c++ 笔记 （六）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-24T00:00:00+08:00" pubdate data-updated="true">Nov 24<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>第10章 同步设备I/O与异步设备I/O</h2>


<p><span style="display:block;text-indent:2em;">打开设备：CreateFile(文件、目录、逻辑磁盘驱动器、物理磁盘驱动器、串口、并口、邮件槽[一对多数据传输]客户端、命名管道[一对一数据传输]客户端)、CreateMailslot、CreateNamedPipe、CreatePipe、Socket、CreateConsoleScreenBuffer,GetFileType</span>
<span style="display:block;text-indent:2em;">CreateFile 的高速缓存标志：FILE_FLAG_NO_BUFFERING(GetDiskFreeSpace扇区的整数倍)，FILE_FLAG_SEQUENTIAL_SCAN，FILE_FLAG_RANDOM_ACCESS，FILE_FLAG_WRITE_THROUGH</span>
<span style="display:block;text-indent:2em;">FILE_FLAG_DELETE_ON_CLOSE、FILE_FLAG_BACKUP_SEMANTICS、FILE_FLAG_OPEN_REPARSE_POINT、FILE_FLAG_OPEN_NO_RECALL、FILE_FLAG_OVERLAPPED</span>
Liquid error: undefined method <code>Py_IsInitialized' for RubyPython::Python:Module
&lt;span style="display:block;text-indent:2em;"&gt;GetFileSizeEx、GetCompressedFileSize、SetFilePointerEx、SetEndOfFile&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;执行同步设备I/O：ReadFile、WriteFile、FlushFileBuffers、CancelSynchronousIo&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;异步：OVERLAPPED结构、CancelIoEx&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;可提醒I/O：QueueUserApc(手动将一项添加到APC队列)、SleepEx、WaitForSingleObjectEx、WaitForMultipleObjectsEx、SignalObjectAndWait、GetQueuedCompletionStatusEx、MsgWaitForMultipleObjectsEx&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;I/O完成端口：CreateCompletionPort、GetQueuedCompletionStatus、PostQueuedCompletionStatus&lt;/span&gt;
Liquid error: undefined method</code>Py_IsInitialized&#8217; for RubyPython::Python:Module
<span style="display:block;text-indent:2em;">FILE_FLAG_NO_BUFFERING标志要求：缓存的起始位置必须是扇区大小的整数倍，VirtualAlloc函数可以确保内存块的起始位置位于分配粒度的边界</span></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/24/learn-windows-progamme-6/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/20/learn-windows-progamme-5/">Windows via C/c++ 笔记 （五）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-20T00:00:00+08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>第8章：用户模式下的线程同步</h2>


<p><span style="display:block;text-indent:2em;">Interlocked系列函数，原子操作，使用时保证传给函数的变量是对齐的，否则可能会失效。_aligned_malloc</span>
<span style="display:block;text-indent:2em;">当一个CPU修改了Cache中一个字节时，其他收到通知，并使自己的Cache作废。应该把只读（不经常读）与可读写的数据分别存放。GetLogicalProcessorInformation,__declspec(align(#))对齐</span>
<span style="display:block;text-indent:2em;">volatile，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。指针不受编译器的优化影响，必须从内存读取。</span>
<span style="display:block;text-indent:2em;">关键段：EnterCriticalSection、LeaveCriticalSection、InitializeCriticalSection、DeleteCriticalSection、CriticalSectionTimeout、TryEnterCriticalSection</span>
<span style="display:block;text-indent:2em;">当线程试图进入被占用的关键段，线程切换到等待状态。这意味着线程从用户模式切换到内核模式（大约 1000 个CPU；周期）。InitializeCriticalSectionAndSpinCount</span>
<span style="display:block;text-indent:2em;">条件变量：SleepConditionVariable*、WakeConditionVariable、WakeAllConditiongVariable</span>
<span style="display:block;text-indent:2em;">以原子方式操作一组对象时使用一个锁；同时访问多个逻辑资源，以相同的顺序获得锁的资源；不长时间占用锁</span></p>

<table linktabletoexcel="yes">
<caption class="table-title">
<span class="table-title">Comparison of Synchronization Mechanism Performance</span>
<br>
</caption>
<thead>
<tr valign="top">
<th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Threads\milliseconds</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Volatile Read</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Volatile Write</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Interlocked Increment</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Critical Section</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">SRWLock Shared</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">SRWLock Exclusive</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Mutex</b>
</p>
</th>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">1</p>
</td><td class="td" align="left">
<p class="table-para">8</p>
</td><td class="td" align="left">
<p class="table-para">8</p>
</td><td class="td" align="left">
<p class="table-para">35</p>
</td><td class="td" align="left">
<p class="table-para">66</p>
</td><td class="td" align="left">
<p class="table-para">66</p>
</td><td class="td" align="left">
<p class="table-para">67</p>
</td><td class="td" align="left">
<p class="table-para">1060</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">2</p>
</td><td class="td" align="left">
<p class="table-para">8</p>
</td><td class="td" align="left">
<p class="table-para">76</p>
</td><td class="td" align="left">
<p class="table-para">153</p>
</td><td class="td" align="left">
<p class="table-para">268</p>
</td><td class="td" align="left">
<p class="table-para">134</p>
</td><td class="td" align="left">
<p class="table-para">148</p>
</td><td class="td" align="left">
<p class="table-para">11082</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">4</p>
</td><td class="td" align="left">
<p class="table-para">9</p>
</td><td class="td" align="left">
<p class="table-para">145</p>
</td><td class="td" align="left">
<p class="table-para">361</p>
</td><td class="td" align="left">
<p class="table-para">768</p>
</td><td class="td" align="left">
<p class="table-para">244</p>
</td><td class="td" align="left">
<p class="table-para">307</p>
</td><td class="td" align="left">
<p class="table-para">23785</p>
</td>
</tr>
</tbody>
</table>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/20/learn-windows-progamme-5/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/17/learn-windows-progamme-4/">Windows via C/c++ 笔记 （四）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-17T00:00:00+08:00" pubdate data-updated="true">Nov 17<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>第6章：线程基础</h2>


<p><span style="display:block;text-indent:2em;">线程由两部分组成：内核对象和线程栈</span>
<span style="display:block;text-indent:2em;">线程共享地址空间、共享内核对象句柄，因为句柄表是针对进程的</span>
<span style="display:block;text-indent:2em;">多线程时可以采用static变量防止对象被销毁，但这会使函数不可重入。（不能创建两个线程执行同一个函数，因为两个线程共享同一个静态变量）</span>
<span style="display:block;text-indent:2em;">ExitThread、TerminateThread、GetExitCodeThread</span>
<span style="display:block;text-indent:2em;">使用<em>beginthreadex而不要用CreateThread，CreateThread不是线程安全的，ExitThread没用释放</em>tiddata(<em>endthreadex释放了)。</em>endthread在调用ExitThread前会调用CloseHandle，而_endthreadex不会。</span>
<span style="display:block;text-indent:2em;">GetCurrentProcess、GetCurrentThread、GetCurrentProcessId、GetCurrentThreadId、DuplicateHandle用于把进程的伪句柄转换为真正的进程句柄</span></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/17/learn-windows-progamme-4/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/15/learn-windows-progamme-3/">Windows via C/c++ 笔记 （三）</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-15T00:00:00+08:00" pubdate data-updated="true">Nov 15<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>第4章：进程</h2>


<p><span style="display:block;text-indent:2em;">进程由内核对象和地址空间组成</span>
<span style="display:block;text-indent:2em;">(w)WinMain的hInstanceExe参数是可执行文件的映像加载到内存的基址；</span>
<span style="display:block;text-indent:2em;">HMODULE和HINSTANCE是一样的，由于win16导致函数名不同；</span>
<span style="display:block;text-indent:2em;">__ImageBase连接器提供的伪变量，指向当前运行模块的基地址</span>
span style=&#8221;display:block;text-indent:2em;&#8221;>GetModuleHandle(NULL)返回进程地址空间中可执行文件的基地址，而非DLL的基地址</span>
Liquid error: undefined method <code>Py_IsInitialized' for RubyPython::Python:Module
&lt;span style="display:block;text-indent:2em;"&gt;GetEnvironmentStrings、FreeEnvironmentStrings，环境变量，读注册表HKEY_CURRENT_USER_ENVIRONMENT&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;SetErrorMode告诉系统如何处理错误&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;目录名、文件名MAX_PATH=260&lt;/span&gt;
&lt;span style="display:block;text-indent:2em;"&gt;GetCurrrentDirectory、SetCurrentDirectory、GetFullPathName&lt;/span&gt;
Liquid error: undefined method</code>Py_IsInitialized&#8217; for RubyPython::Python:Module</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/15/learn-windows-progamme-3/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/13/java-nio-demo/">Java Nio Demo</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-11-13T00:00:00+08:00" pubdate data-updated="true">Nov 13<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><span style="display:block;text-indent:2em;">J2SE1.4中引入了新I/O库(NIO)来解决这个问题。NIO使用面向缓冲(buffer)的模型。这就是说，NIO主要处理大块的数据。这就避免了利用流模型处理所引起的问题，在有可能的情况下，它甚至可以为了得到最大的吞吐量而使用系统级的工具。</span></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/11/13/java-nio-demo/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/05/12/hello-world/">hello, world</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/03/15/plan/">read some source code in the next few months</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/10/goodbye-c-sharp/">Goodbye C Sharp</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/12/09/learn-windows-progamme-8/">windows via c/c++ 笔记 （八）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/30/learn-windows-progamme-7/">windows via c/c++ 笔记 （七）</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Peng Fei -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'airpfei';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
