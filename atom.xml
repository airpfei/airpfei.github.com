<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blog Of Peng Fei]]></title>
  <link href="http://airpfei.github.com/atom.xml" rel="self"/>
  <link href="http://airpfei.github.com/"/>
  <updated>2012-05-15T01:00:34+08:00</updated>
  <id>http://airpfei.github.com/</id>
  <author>
    <name><![CDATA[Peng Fei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[hello, world]]></title>
    <link href="http://airpfei.github.com/blog/2012/05/12/hello-world/"/>
    <updated>2012-05-12T02:47:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2012/05/12/hello-world</id>
    <content type="html"><![CDATA[<p>hello, world</p>

<p>折腾一晚上 octopress 终于有点成效了！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[read some source code in the next few months]]></title>
    <link href="http://airpfei.github.com/blog/2012/03/15/plan/"/>
    <updated>2012-03-15T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2012/03/15/plan</id>
    <content type="html"><![CDATA[<p>modern c++ design let me know c++ template can do much more, although i can&#8217;t complete understand. i need read it again.</p>

<p>loki, chrome, linux kernel i really want to read.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goodbye C Sharp]]></title>
    <link href="http://airpfei.github.com/blog/2011/12/10/goodbye-c-sharp/"/>
    <updated>2011-12-10T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/12/10/goodbye-c-sharp</id>
    <content type="html"><![CDATA[<p><span style="display:block;text-indent:2em;">公司一款产品的最后的一个版本即将发布，以后在这款产品上只是一些例行的维护，不会再有什么重大的变化。这是一套以.net框架为基础的产品，由于性能问题，ui的掌控的问题使得公司最终放弃.net框架。</span>
<span style="display:block;text-indent:2em;">我从2009年8月开始接触.net，一边学习，一边实践。经过2年C#编程，也对C#及.net框架有一些了解。先先说一下有点吧，那就是简单。.net把对字符串、Window、network的操作变得非常简单。但是由于.net的封装，使得一些底层的操作非常困难。例如，给Window设置一个Class，至今我还不知道如何设置。又如WinForm原生控件的定制性很差，不能满足一些常用的需求，有时必须使用Win32Api来完成。还有就是.net本身的性能问题，使得很多商业软件放弃使用。</span>
<span style="display:block;text-indent:2em;">当然，在这两年里，也接触了一些.net框架中比较新的东西，如WPF。不得不承认WPF把UI实现变得很容易。但WPF对设备性能的要求，对.net版本的要求使得许多商业软件放弃使用。要知道在Win xp占有率达到75%的天朝，.net3.5是多么遥不可及！</span>
<span style="display:block;text-indent:2em;">对一些企业内部的管理软件，.net还是很适合的，节约开发成本。如果开发者对Windows的内存没有很好的掌控力，使用C/C++有可能适得其反。.net的GC使得开发者不用花很多精力放在内存管理上。觉得WinPhone可能会让C#上升到一个新的高度</span>
<span style="display:block;text-indent:2em;">感觉silverlight的死期不远了，html5使得silverlight没有什么存在的价值了。</span>
<span style="display:block;text-indent:2em;">即将告别C#投向C++阵营，还是很感谢C#的，毕竟之前我是用它混饭的。一直很想使用C++编程，因为这是一门公认的复杂语言，也应为我能更近距离的接触操作系统。</span>
<span style="display:block;text-indent:2em;">白天折腾了很久mp4box，学习到一点C++的调试技巧。在link错误时，编译器表错为<em>function not found，开始以为</em>function是函数名，结果搜了半天没找到，最后才发现“_”不是函数名的一部分。</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （八）]]></title>
    <link href="http://airpfei.github.com/blog/2011/12/09/learn-windows-progamme-8/"/>
    <updated>2011-12-09T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/12/09/learn-windows-progamme-8</id>
    <content type="html"><![CDATA[<h2>第19章 DLL基础</h2>


<p><span style="display:block;text-indent:2em;">一般在dll中分配的内存，都需要通过dll释放</span>
<span style="display:block;text-indent:2em;">DLL若连接的是静态版本，那么DLL的代码里面就会有一份free和malloc的代码，若EXE也使用的是静态版本的C/C++运行库，那么也会有另一份代码。当然你使用DLL代码里申请的内存不能在EXE的free代码中释放。原因是因为有两个不通的堆管理，在EXE中查不到相应申请的内存，自然释放会失败。</span>
<span style="display:block;text-indent:2em;">导出函数或变量，链接器生成lib文件。</span>
<span style="display:block;text-indent:2em;">dumpbin -exports *.dll</span>
<span style="display:block;text-indent:2em;">dumpbin -imports *.exe</span>
<span style="display:block;text-indent:2em;">避免MS VC++的名字粉碎(Name Mangling)：.def文件EXPORTS段导出函数名；extern &#8220;C&#8221;；#pragma comment (linker, &#8220;/export:MyFunc=_MyFunc@8&#8221;)</span>
<span style="display:block;text-indent:2em;">导入：__declspec(dllimport)或使用extern</span>
<span style="display:block;text-indent:2em;">运行可执行模块：操作系统加载程序为进程创建虚拟地址空间，把可执行模块映射到进程的地址空间中。之后加载程序会检查可执行模块的导入段(不同版本的dll可能在这个步骤出问题)，对所需的DLL进行定位并将其映射到进程的地址空间中。</span>
<span style="display:block;text-indent:2em;">基址重定位和绑定可以加快应用程序初始化速度。</span></p>

<h2>第20章 DLL高级技术</h2>


<p><span style="display:block;text-indent:2em;">LoadLibrary(Ex)、FreeLibrary、FreeLibraryAndExitThread、GetModuleHandle、GetModuleFileName</span>
<span style="display:block;text-indent:2em;">GetProcAddress</span>
<span style="display:block;text-indent:2em;">DllMain的序列化调用。DisableThreadLibraryCalls</span>
<span style="display:block;text-indent:2em;">延迟载入DLL：当我们的代码试图引用DLL包含的符号时载入DLL。加快初始化速度；解决老版本DLL没有一些函数的问题。</span>
<span style="display:block;text-indent:2em;">一个导出全局变量的DLL、Kernel32.dll无法延迟加载。不应在DllMain中调用延迟加载的函数。</span>
<span style="display:block;text-indent:2em;">VcppException延迟载入DLL异常处理，DelayLoadInfo</span>
<span style="display:block;text-indent:2em;">函数转发器：#pragma comment (linker, &#8220;/export:SomeFunc=Dllwork.SomeOtherFunc&#8221;)</span>
<span style="display:block;text-indent:2em;">模块的基地址重定位，显著提高整个系统的性能。/FIXED不包含重定位段。</span>
<span style="display:block;text-indent:2em;">模块的绑定，提高性能，不必再对模块重新定位，不必查看导入函数的虚拟地址。</span></p>

<h2>第21章 线程局部存储区</h2>


<p><span style="display:block;text-indent:2em;">动态TSL：TlsAlloc、TlsSetValue、TlsGetValue、TlsFree</span>
<span style="display:block;text-indent:2em;">静态TLS：__declspec(thread)</span></p>

<h2>第22章 DLL注入和API拦截</h2>


<p><span style="display:block;text-indent:2em;"><a href="http://www.codeproject.com/KB/system/inject2it.aspx" target="_blank">Demo</a></span>
<span style="display:block;text-indent:2em;">SetWindowLongPtr。从根本上将，DLL注入是目标进程中的一个线程调用LoadLibrary载入我们想要的DLL。</span>
<span style="display:block;text-indent:2em;">使用注册表注入DLL：只会映射到使用Use32.dll的进程中</span>
<span style="display:block;text-indent:2em;">使用Windows挂钩注入DLL：SetWindowsHookEx、UnhookWindowsHookEx。使用PostThreadMessage线程同步。</span>
<span style="display:block;text-indent:2em;">使用远程线程注入DLL：CreateRemoteThread、VirtualAllocEx、VirtualFreeEx、ReadProcessMemory、WriteProcessMemory</span></p>

<h2>结构化异常处理</h2>


<p><span style="display:block;text-indent:2em;"><strong>try中使用return、goto、longjump，</strong>finally中的代码也会被执行。</span>
<span style="display:block;text-indent:2em;"><strong>try, </strong>finally 框架会使finally中的代码执行</span>
<span style="display:block;text-indent:2em;">__leave关键字会使执行代码跳转到try块的结尾。</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （七）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/30/learn-windows-progamme-7/"/>
    <updated>2011-11-30T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/30/learn-windows-progamme-7</id>
    <content type="html"><![CDATA[<h2>第13章 Windows内存体系结构</h2>


<p><span style="display:block;text-indent:2em;">need reread</span>
<span style="display:block;text-indent:2em;">空指针赋值分区、用户模式分区、64KB禁入分区、内核模式分区</span>
<span style="display:block;text-indent:2em;">32位App运行在64位Windows分配的0x00000000&#8217;7FFFFFFF以下的地址空间，64位App默认在0x00000000&#8217;80000000以上的地址空间</span>
<span style="display:block;text-indent:2em;">系统会确保VirtualAlloc预订的地址区域的起始地址是分配粒度(allocation granularity)的整数倍</span>
<span style="display:block;text-indent:2em;">一个块是一些连续的页面</span></p>

<h2>第14章 探索虚拟内存</h2>


<p><span style="display:block;text-indent:2em;">系统信息：GetSystemInfo、GetLogicalProcessorInformation、IsWow64Process、GetCurrentProcess</span>
<span style="display:block;text-indent:2em;">虚拟内存状态：GlobalMemoryStatus(Ex)</span>
<span style="display:block;text-indent:2em;">NUMA机器中的内存管理：GetNumaAvailableMemoryNode、GetNumaProcessNode、GetNumaHighestNodeNumber、GetNumaNodeProcessorMask</span>
地址空间的状态：VirtualQuery(Ex)
<span style="display:block;text-indent:2em;">/dynamicbase  进程共享ASLR基址重定向的页面</span></p>

<h2>第15章 在应用程序中使用虚拟内存</h2>


<p><span style="display:block;text-indent:2em;">虚拟内存：管理大型对象数组或大型数据结构数组</span>
<span style="display:block;text-indent:2em;">内存映射文件：管理大型数据流，多进程共享数据</span>
<span style="display:block;text-indent:2em;">堆：管理大量小型对象</span>
<span style="display:block;text-indent:2em;">VirtualAlloc、VirtualFree、VirtualQuery、VirtualProtect</span>
地址窗口扩展(AWE)(使用物理内存，提高性能)：AllocateUserPhysicalPages、MapUserPhysicalPages、FreeUserPhysicalPages</p>

<h2>第16章 线程栈</h2>


<p><span style="display:block;text-indent:2em;">SetThreadStackGuarante</span></p>

<!--more-->




<h2>第17章 内存映射文件</h2>


<p><span style="display:block;text-indent:2em;">映射到内存的EXE和DLL</span>
<span style="display:block;text-indent:2em;">一个应用程序的多个实例共享内存中的代码和数据，避免一个实例修改全局变量导致错误，系统通过内存管理的写时复制特性防止此发生。数据写写入时，系统会为其开辟一块新的内存。</span>
<span style="display:block;text-indent:2em;">#pragma data_seg(&#8220;name&#8221;) 用来创建名为&#8221;name&#8221;的段，该段内的数据必须初始化，否则数据不属于该段</span>
<span style="display:block;text-indent:2em;">allocate允许将未初始化的数据放入莫个段中</span>
<span style="display:block;text-indent:2em;">为数据创建单独的段是为了多个实例共享数据。编译选项/SECTION:name,attributes。#pragma comment(linker, &#8220;SECTION:Shared, RWS&#8221;)</span>
<span style="display:block;text-indent:2em;">_tscrev颠倒文件数据(0结尾)</span>
<span style="display:block;text-indent:2em;">CreateFile(失败为NULL或INVALID_HANDLE_VALUE) &#8211;> CreateFileMapping (告诉系统映射文件需要多大的物理内存) &#8211;> MapViewOfFile &#8211;> UnmapViewOfFile &#8211;> FlushViewOfFile &#8211;> CloseHandle</span>
<span style="display:block;text-indent:2em;">MoveMemory</span>
<span style="display:block;text-indent:2em;">只读文件适合用于内存映射文件。可写文件不适合(无法保证一致性)，应独占文件(dwShareMode = 0)。</span>
<span style="display:block;text-indent:2em;">以页交换文件为后备存储器的内存映射文件：CreateFileMapping时hFile = INVALID_HANDLE_VALUE</span>
<span style="display:block;text-indent:2em;">稀疏调拨的内存映射文件：CreateMapping时传入SEC_RESERVE标志，系统不会从页交换文件中调拨物理存储器。然后使用VirtualAlloc调拨物理内存</span></p>

<h2>第18章 堆</h2>


<p><span style="display:block;text-indent:2em;">GetProcessHeap获取进程默认堆句柄。默认堆只允许一个线程访问。</span>
<span style="display:block;text-indent:2em;">HeapCreate、HeapAlloc、HeapSize、HeapFree、HeapDestroy</span>
<span style="display:block;text-indent:2em;">GetProcessHeaps、HeapValidate、HeapCompact、HeapLock、HeapUnlock、HeapWalk</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （六）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/24/learn-windows-progamme-6/"/>
    <updated>2011-11-24T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/24/learn-windows-progamme-6</id>
    <content type="html"><![CDATA[<h2>第10章 同步设备I/O与异步设备I/O</h2>


<p><span style="display:block;text-indent:2em;">打开设备：CreateFile(文件、目录、逻辑磁盘驱动器、物理磁盘驱动器、串口、并口、邮件槽[一对多数据传输]客户端、命名管道[一对一数据传输]客户端)、CreateMailslot、CreateNamedPipe、CreatePipe、Socket、CreateConsoleScreenBuffer,GetFileType</span>
<span style="display:block;text-indent:2em;">CreateFile 的高速缓存标志：FILE_FLAG_NO_BUFFERING(GetDiskFreeSpace扇区的整数倍)，FILE_FLAG_SEQUENTIAL_SCAN，FILE_FLAG_RANDOM_ACCESS，FILE_FLAG_WRITE_THROUGH</span>
<span style="display:block;text-indent:2em;">FILE_FLAG_DELETE_ON_CLOSE、FILE_FLAG_BACKUP_SEMANTICS、FILE_FLAG_OPEN_REPARSE_POINT、FILE_FLAG_OPEN_NO_RECALL、FILE_FLAG_OVERLAPPED</span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HANDLE hFile = CreateFile(...);
</span><span class='line'>if (hFile == NULL) {
</span><span class='line'>   // We'll never get in here
</span><span class='line'>} else {
</span><span class='line'>   // File might or might not be created OK
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//Here's the correct way to check for an invalid file handle:
</span><span class='line'>HANDLE hFile = CreateFile(...);
</span><span class='line'>if (hFile == INVALID_HANDLE_VALUE) {
</span><span class='line'>   // File not created
</span><span class='line'>} else {
</span><span class='line'>   // File created OK
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><span style="display:block;text-indent:2em;">GetFileSizeEx、GetCompressedFileSize、SetFilePointerEx、SetEndOfFile</span>
<span style="display:block;text-indent:2em;">执行同步设备I/O：ReadFile、WriteFile、FlushFileBuffers、CancelSynchronousIo</span>
<span style="display:block;text-indent:2em;">异步：OVERLAPPED结构、CancelIoEx</span>
<span style="display:block;text-indent:2em;">可提醒I/O：QueueUserApc(手动将一项添加到APC队列)、SleepEx、WaitForSingleObjectEx、WaitForMultipleObjectsEx、SignalObjectAndWait、GetQueuedCompletionStatusEx、MsgWaitForMultipleObjectsEx</span>
<span style="display:block;text-indent:2em;">I/O完成端口：CreateCompletionPort、GetQueuedCompletionStatus、PostQueuedCompletionStatus</span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//为了只创建I/O完成端口，只需要设置第四个参数。dwNumberOfConcurrentThreads (并发线程数量) = 0，系统默认为CPU的数量
</span><span class='line'>HANDLE CreateNewCompletionPort(DWORD dwNumberOfConcurrentThreads) {
</span><span class='line'>   return(CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0,
</span><span class='line'>      dwNumberOfConcurrentThreads));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><span style="display:block;text-indent:2em;">FILE_FLAG_NO_BUFFERING标志要求：缓存的起始位置必须是扇区大小的整数倍，VirtualAlloc函数可以确保内存块的起始位置位于分配粒度的边界</span></p>

<!--more-->


<h2>第11章 Windows线程池</h2>


<p><span style="display:block;text-indent:2em;">异步调用函数：CreateThreadpoolWork、TrySubmitThreadpoolWork、SubmitThreadpoolWork、WaitForThreadpoolWorkCallbacks、CloseThreadpoolWork</span>
<span style="display:block;text-indent:2em;">每隔一段时间调用函数：CreateThreadpoolTimer、SetThreadpoolTimer、WaitForThreadpoolTimerCallbacks、IsThreadpoolTimerSet、CloseThreadpoolTimer</span>
<span style="display:block;text-indent:2em;">内核对象出发时调用函数：CreateThreadpoolWait、SetThreadpoolWait、CloseThreadpoolWait</span>
<span style="display:block;text-indent:2em;">异步I/O请求完成时调用函数：CreateThreadpoolIo、StartThreadpoolIo、CancelThreadpoolIo、CloseThreadpoolIo</span>
<span style="display:block;text-indent:2em;">the default thread pool has the minimum number of threads set to 1 and its maximum number of threads set to 500</span></p>

<h2>第12章 纤程</h2>


<p><span style="display:block;text-indent:2em;">尽量避免使用纤程</span>
<span style="display:block;text-indent:2em;">ConvertThreadToFiber(Ex)、CreateFiber(Ex)、SwitchToFiber、DeleteFiber、GetCurrentFiber、GetFiberData</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （五）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/20/learn-windows-progamme-5/"/>
    <updated>2011-11-20T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/20/learn-windows-progamme-5</id>
    <content type="html"><![CDATA[<h2>第8章：用户模式下的线程同步</h2>


<p><span style="display:block;text-indent:2em;">Interlocked系列函数，原子操作，使用时保证传给函数的变量是对齐的，否则可能会失效。_aligned_malloc</span>
<span style="display:block;text-indent:2em;">当一个CPU修改了Cache中一个字节时，其他收到通知，并使自己的Cache作废。应该把只读（不经常读）与可读写的数据分别存放。GetLogicalProcessorInformation,__declspec(align(#))对齐</span>
<span style="display:block;text-indent:2em;">volatile，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。指针不受编译器的优化影响，必须从内存读取。</span>
<span style="display:block;text-indent:2em;">关键段：EnterCriticalSection、LeaveCriticalSection、InitializeCriticalSection、DeleteCriticalSection、CriticalSectionTimeout、TryEnterCriticalSection</span>
<span style="display:block;text-indent:2em;">当线程试图进入被占用的关键段，线程切换到等待状态。这意味着线程从用户模式切换到内核模式（大约 1000 个CPU；周期）。InitializeCriticalSectionAndSpinCount</span>
<span style="display:block;text-indent:2em;">条件变量：SleepConditionVariable*、WakeConditionVariable、WakeAllConditiongVariable</span>
<span style="display:block;text-indent:2em;">以原子方式操作一组对象时使用一个锁；同时访问多个逻辑资源，以相同的顺序获得锁的资源；不长时间占用锁</span></p>

<table linktabletoexcel="yes">
<caption class="table-title">
<span class="table-title">Comparison of Synchronization Mechanism Performance</span>
<br>
</caption>
<thead>
<tr valign="top">
<th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Threads\milliseconds</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Volatile Read</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Volatile Write</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Interlocked Increment</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Critical Section</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">SRWLock Shared</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">SRWLock Exclusive</b>
</p>
</th><th class="th" scope="col" align="left">
<p class="table-para">
<b class="bold">Mutex</b>
</p>
</th>
</tr>
</thead>
<tbody>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">1</p>
</td><td class="td" align="left">
<p class="table-para">8</p>
</td><td class="td" align="left">
<p class="table-para">8</p>
</td><td class="td" align="left">
<p class="table-para">35</p>
</td><td class="td" align="left">
<p class="table-para">66</p>
</td><td class="td" align="left">
<p class="table-para">66</p>
</td><td class="td" align="left">
<p class="table-para">67</p>
</td><td class="td" align="left">
<p class="table-para">1060</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">2</p>
</td><td class="td" align="left">
<p class="table-para">8</p>
</td><td class="td" align="left">
<p class="table-para">76</p>
</td><td class="td" align="left">
<p class="table-para">153</p>
</td><td class="td" align="left">
<p class="table-para">268</p>
</td><td class="td" align="left">
<p class="table-para">134</p>
</td><td class="td" align="left">
<p class="table-para">148</p>
</td><td class="td" align="left">
<p class="table-para">11082</p>
</td>
</tr>
<tr valign="top">
<td class="td" align="left">
<p class="table-para">4</p>
</td><td class="td" align="left">
<p class="table-para">9</p>
</td><td class="td" align="left">
<p class="table-para">145</p>
</td><td class="td" align="left">
<p class="table-para">361</p>
</td><td class="td" align="left">
<p class="table-para">768</p>
</td><td class="td" align="left">
<p class="table-para">244</p>
</td><td class="td" align="left">
<p class="table-para">307</p>
</td><td class="td" align="left">
<p class="table-para">23785</p>
</td>
</tr>
</tbody>
</table>




<!--more-->


<h2>第9章：用内核对象进行线程同步</h2>


<p><span style="display:block;text-indent:2em;">WaitForSingleObject、WaitForMultipleObjects，内核对象被触发返回。等待成功引起的副作用，由于事件对象触发时，在返回WAIT_OBJECT_0前会使对象变为非触发状态</span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HANDLE h[2];
</span><span class='line'>h[0] = hAutoResetEvent1;   // Initially nonsignaled
</span><span class='line'>h[1] = hAutoResetEvent2;   // Initially nonsignaled
</span><span class='line'>WaitForMultipleObjects(2, h, TRUE, INFINITE);</span></code></pre></td></tr></table></div></figure>


<p><span style="display:block;text-indent:2em;">hAutoResetEvent1先触发，hAutoResetEvent2触发，两线程的一个检测到触发，系统把两个事件对象都设为未触发</span>
<span style="display:block;text-indent:2em;">事件内核对象：CreateEvent(Ex)、SetEvent、ResetEvent、PulseEvent(不经常使用)、OpenEvent(DuplicateHandle)。使用自动重置的对象，当对象被触发，系统只会让次要线程中的一个变为可调度状态，所以要在每个次要线程调用时使用SetEvent，否则其他次要线程将等待。</span>
<span style="display:block;text-indent:2em;">可等待的计时器内核对象：CreateWaitableTimer、SetWaitableTimer、CancelWaitableTimer、OpenWaitableTimer</span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void SomeFunc() {
</span><span class='line'>   // Create a timer. (It doesn't matter whether it's manual-reset
</span><span class='line'>   // or auto-reset.)
</span><span class='line'>   HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL);
</span><span class='line'>
</span><span class='line'>   // Set timer to go off in 5 seconds.
</span><span class='line'>   LARGE_INTEGER li = { 0 };
</span><span class='line'>   SetWaitableTimer(hTimer, &amp;li, 5000, TimerAPCRoutine, NULL, FALSE);
</span><span class='line'>
</span><span class='line'>   //APC异步函数被插入线程，线程恢复
</span><span class='line'>   // Wait in an alertable state for the timer to go off.
</span><span class='line'>   SleepEx(INFINITE, TRUE);
</span><span class='line'>
</span><span class='line'>   CloseHandle(hTimer);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><span style="display:block;text-indent:2em;">信号量内核对象：CreateSemaphore、OpenSemaphore、ReleaseSemaphore</span>
<span style="display:block;text-indent:2em;">互斥量内核对象：CreateMutex、OpenMutex、RleaseMutex</span>
<span style="display:block;text-indent:2em;">WaitForInputIdle、MsgWaitForMultipleObjects(Ex)(用户界面相关的线程使用)、WaitForDebugEvent、SignalObjectAndWait(通过原子操作让一个内核对象等待另一个内核对象)</span>
<span style="display:block;text-indent:2em;">等待链遍历API检测死锁：ParseThreads、OpenThreadWaitChainSession、GetThreadChain</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （四）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/17/learn-windows-progamme-4/"/>
    <updated>2011-11-17T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/17/learn-windows-progamme-4</id>
    <content type="html"><![CDATA[<h2>第6章：线程基础</h2>


<p><span style="display:block;text-indent:2em;">线程由两部分组成：内核对象和线程栈</span>
<span style="display:block;text-indent:2em;">线程共享地址空间、共享内核对象句柄，因为句柄表是针对进程的</span>
<span style="display:block;text-indent:2em;">多线程时可以采用static变量防止对象被销毁，但这会使函数不可重入。（不能创建两个线程执行同一个函数，因为两个线程共享同一个静态变量）</span>
<span style="display:block;text-indent:2em;">ExitThread、TerminateThread、GetExitCodeThread</span>
<span style="display:block;text-indent:2em;">使用<em>beginthreadex而不要用CreateThread，CreateThread不是线程安全的，ExitThread没用释放</em>tiddata(<em>endthreadex释放了)。</em>endthread在调用ExitThread前会调用CloseHandle，而_endthreadex不会。</span>
<span style="display:block;text-indent:2em;">GetCurrentProcess、GetCurrentThread、GetCurrentProcessId、GetCurrentThreadId、DuplicateHandle用于把进程的伪句柄转换为真正的进程句柄</span></p>

<!--more-->


<h2>第7章：线程调度、优先级和关联性</h2>


<p><span style="display:block;text-indent:2em;">ResumeThread、SuspendThread，当挂起数为0时，线程可调度</span>
<span style="display:block;text-indent:2em;">WaitForDebugEvent挂起进程中所有线程，直至ContinueDebugEvent</span>
<span style="display:block;text-indent:2em;">SwitchToThread与Sleep(0)类似，SwitchToThread允许执行低优先级的线程而Sleep不可以</span>
<span style="display:block;text-indent:2em;">GetTickCount64、GetThreadTimes、GetProcessTimes、QueryThreadCycleTime、QueryProcessCycleTime、ReadTimeStampCounter、QueryPerformanceFrequency、QueryPerformanceCounter</span>
<span style="display:block;text-indent:2em;">调用GetThreadContext前应调用SuspendThread否则可能会导致Context信息不一致</span>
<span style="display:block;text-indent:2em;">SetPriorityClass、SetProcessPriorityBoost、SetThreadPriorityBoost</span>
<span style="display:block;text-indent:2em;">SetProcessAffinityMask、GetProcessAffinityMask、SetThreadIdealProcessor关联性</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （三）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/15/learn-windows-progamme-3/"/>
    <updated>2011-11-15T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/15/learn-windows-progamme-3</id>
    <content type="html"><![CDATA[<h2>第4章：进程</h2>


<p><span style="display:block;text-indent:2em;">进程由内核对象和地址空间组成</span>
<span style="display:block;text-indent:2em;">(w)WinMain的hInstanceExe参数是可执行文件的映像加载到内存的基址；</span>
<span style="display:block;text-indent:2em;">HMODULE和HINSTANCE是一样的，由于win16导致函数名不同；</span>
<span style="display:block;text-indent:2em;">__ImageBase连接器提供的伪变量，指向当前运行模块的基地址</span>
span style=&#8221;display:block;text-indent:2em;&#8221;>GetModuleHandle(NULL)返回进程地址空间中可执行文件的基地址，而非DLL的基地址</span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//使用HeapFree释放内存
</span><span class='line'>PWSTR *ppArgv = CommandLineToArgvW(GetCommandLineW(), &amp;nNumArgs);
</span><span class='line'>// Use the arguments…
</span><span class='line'>if (*ppArgv[1] == L'x') {
</span><span class='line'>   ...
</span><span class='line'>}
</span><span class='line'>// Free the memory block
</span><span class='line'>HeapFree(GetProcessHeap(), 0, ppArgv);</span></code></pre></td></tr></table></div></figure>


<p><span style="display:block;text-indent:2em;">GetEnvironmentStrings、FreeEnvironmentStrings，环境变量，读注册表HKEY_CURRENT_USER_ENVIRONMENT</span>
<span style="display:block;text-indent:2em;">SetErrorMode告诉系统如何处理错误</span>
<span style="display:block;text-indent:2em;">目录名、文件名MAX_PATH=260</span>
<span style="display:block;text-indent:2em;">GetCurrrentDirectory、SetCurrentDirectory、GetFullPathName</span></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PROCESS_INFORMATION pi;
</span><span class='line'>DWORD dwExitCode;
</span><span class='line'>// Spawn the child process.
</span><span class='line'>BOOL fSuccess = CreateProcess(..., &amp;pi);
</span><span class='line'>if (fSuccess) {
</span><span class='line'>   // Close the thread handle as soon as it is no longer needed!
</span><span class='line'>   //！！！递减子进程的主线程内核对象使用计数。使系统能够正常释放子进程
</span><span class='line'>   CloseHandle(pi.hThread);
</span><span class='line'>   // Suspend our execution until the child has terminated.
</span><span class='line'>   WaitForSingleObject(pi.hProcess, INFINITE);
</span><span class='line'>   // The child process terminated; get its exit code.
</span><span class='line'>   GetExitCodeProcess(pi.hProcess, &amp;dwExitCode);
</span><span class='line'>   // Close the process handle as soon as it is no longer needed.
</span><span class='line'>   CloseHandle(pi.hProcess);
</span><span class='line'>}
</span><span class='line'>// 运行独立的子进程
</span><span class='line'>BOOL fSuccess = CreateProcess(..., &amp;pi);
</span><span class='line'>if (fSuccess) {
</span><span class='line'>   // Allow the system to destroy the process &amp; thread kernel
</span><span class='line'>   // objects as soon as the child process terminates.
</span><span class='line'>   CloseHandle(pi.hThread);
</span><span class='line'>   CloseHandle(pi.hProcess);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<!--more-->


<br />


<h2>第5章：作业</h2>


<p><span style="display:block;text-indent:2em;">Windows提供了作业（Job）内核对象，将进城组合在一起并创建一个“沙箱”来限制进程</span>
<span style="display:block;text-indent:2em;">如果未定义manifest或debug，windows资源管理器会将进程同“PCA”前缀的作业关联，可以从cmd启动进程</span>
<span style="display:block;text-indent:2em;">CreateJobObject、OpenJobObject、UserHandleGrantAccess、SetInformationJobObject、AssignProcessToJobObject、TerminateJobObject、QueryInformationJobObject、GetQueuedCompletionStatus</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java nio demo]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/13/java-nio-demo/"/>
    <updated>2011-11-13T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/13/java-nio-demo</id>
    <content type="html"><![CDATA[<p><span style="display:block;text-indent:2em;">J2SE1.4中引入了新I/O库(NIO)来解决这个问题。NIO使用面向缓冲(buffer)的模型。这就是说，NIO主要处理大块的数据。这就避免了利用流模型处理所引起的问题，在有可能的情况下，它甚至可以为了得到最大的吞吐量而使用系统级的工具。</span></p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import java.io.IOException;
</span><span class='line'>import java.net.InetSocketAddress;
</span><span class='line'>import java.net.ServerSocket;
</span><span class='line'>import java.net.Socket;
</span><span class='line'>import java.nio.ByteBuffer;
</span><span class='line'>import java.nio.channels.*;
</span><span class='line'>import java.util.Set;
</span><span class='line'>
</span><span class='line'>public class TestChannel {
</span><span class='line'>    public static void main(String args[]) throws IOException{
</span><span class='line'>        TestChannel tt=new TestChannel();
</span><span class='line'>        //tt.initServerChannel(992);
</span><span class='line'>        tt.initSelector(992);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //最初的java  socket实现方式，直接通过serversocket和socket通信
</span><span class='line'>    public void initServerSocket(int port) throws IOException{
</span><span class='line'>        ServerSocketChannel ssc=ServerSocketChannel.open();
</span><span class='line'>        //ssc.configureBlocking(false);
</span><span class='line'>        ServerSocket ss=new ServerSocket(port);
</span><span class='line'>        while(true){
</span><span class='line'>            Socket socket=ss.accept();
</span><span class='line'>                System.out.println(&quot;socket accepted&quot;);
</span><span class='line'>                byte[] buf=new byte[1024];
</span><span class='line'>                try{
</span><span class='line'>                socket.getInputStream().read(buf);
</span><span class='line'>                }
</span><span class='line'>                catch(Exception ex){
</span><span class='line'>                    socket.close();
</span><span class='line'>                }
</span><span class='line'>                System.out.println(new String(buf));
</span><span class='line'>
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    //通过Channel实现的non-blocking通信方式
</span><span class='line'>    public void initServerChannel(int port) throws IOException{
</span><span class='line'>        ServerSocketChannel ssc=ServerSocketChannel.open();
</span><span class='line'>        ssc.configureBlocking(false);
</span><span class='line'>        ServerSocket ss=ssc.socket();
</span><span class='line'>        ss.bind(new InetSocketAddress(port));
</span><span class='line'>        while(true){
</span><span class='line'>            SocketChannel sc=ssc.accept();
</span><span class='line'>            if(sc!=null){
</span><span class='line'>                Socket socket=sc.socket();
</span><span class='line'>                System.out.println(&quot;socket accepted&quot;);
</span><span class='line'>                byte[] buf=new byte[1024];
</span><span class='line'>                try{
</span><span class='line'>                socket.getInputStream().read(buf);
</span><span class='line'>                }
</span><span class='line'>                catch(Exception ex){
</span><span class='line'>                    socket.close();
</span><span class='line'>                }
</span><span class='line'>                System.out.println(new String(buf));
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    //通过selector和channel进行multiplexed通信,像mina就是通过这种方式实现的
</span><span class='line'>    public void initSelector(int port) throws IOException{
</span><span class='line'>        Selector selector=Selector.open();
</span><span class='line'>        //register server channel
</span><span class='line'>        ServerSocketChannel ssc=ServerSocketChannel.open();
</span><span class='line'>        ssc.configureBlocking(false);
</span><span class='line'>        ServerSocket ss=ssc.socket();
</span><span class='line'>        ss.bind(new InetSocketAddress(port));
</span><span class='line'>        ssc.register(selector, SelectionKey.OP_ACCEPT);
</span><span class='line'>        while(true){
</span><span class='line'>            int interestNo=selector.select();
</span><span class='line'>            if(interestNo==0)
</span><span class='line'>                continue;
</span><span class='line'>            Set keys=selector.selectedKeys();
</span><span class='line'>            for(SelectionKey key:keys){
</span><span class='line'>                //接受Socket连接请求
</span><span class='line'>                if(key.isAcceptable()){
</span><span class='line'>                    SocketChannel sc=ssc.accept();
</span><span class='line'>                    try{
</span><span class='line'>                    sc.configureBlocking(false);
</span><span class='line'>                    sc.register(selector, SelectionKey.OP_READ);
</span><span class='line'>                    }
</span><span class='line'>                    catch(Exception ex){
</span><span class='line'>                        sc.close();
</span><span class='line'>                    }
</span><span class='line'>                    System.out.println(&quot;connection accepted&quot;);
</span><span class='line'>                    keys.remove(key);
</span><span class='line'>                }
</span><span class='line'>                else if(key.isReadable()){
</span><span class='line'>                    SocketChannel sc=(SocketChannel)key.channel();
</span><span class='line'>                    ByteBuffer bbuf=ByteBuffer.allocate(1024);
</span><span class='line'>                    try{
</span><span class='line'>                    sc.read(bbuf);
</span><span class='line'>                    }
</span><span class='line'>                    catch(Exception ex){
</span><span class='line'>                        sc.close();
</span><span class='line'>                    }
</span><span class='line'>                    System.out.println(new String(bbuf.array()));
</span><span class='line'>                    keys.remove(key);
</span><span class='line'>                }
</span><span class='line'>                else
</span><span class='line'>                    keys.remove(key);
</span><span class='line'>                    continue;
</span><span class='line'>
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>// client:
</span><span class='line'>
</span><span class='line'>//Java代码
</span><span class='line'>public class TestChannelClient {
</span><span class='line'>public static void main(String args[]) throws UnknownHostException, IOException{
</span><span class='line'>    Socket sc=new Socket(&quot;127.0.0.1&quot;,992);
</span><span class='line'>    OutputStream out=sc.getOutputStream();
</span><span class='line'>    out.write(&quot;hello&quot;.getBytes());
</span><span class='line'>    out.flush();
</span><span class='line'>}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （二）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/12/learn-windows-progamme-2/"/>
    <updated>2011-11-12T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/12/learn-windows-progamme-2</id>
    <content type="html"><![CDATA[<h2>第3章：内核对象</h2>


<p><span style="display:block;text-indent:2em;">每个内核对象是一个内存块，由操作系统分配，并只能由操作系统内核访问。</span>
<span style="display:block;text-indent:2em;">调用函数创建内核对象时，调用失败句柄值通常为NULL，有几个函数返回值为-1 INVALID_HANDLE_VALUE。用于创建内核对象的函数检查返回值时要谨慎。</span>
<span style="display:block;text-indent:2em;">调用CloseHandle关闭内核对象时，应将内核对象的变量设为NULL。 </span>
<span style="display:block;text-indent:2em;">Creat<em>，Open</em></span>
<span style="display:block;text-indent:2em;">共享内核对象：对象句柄继承，为对象命名，复制对象句柄</span>
<span style="display:block;text-indent:2em;">sample为专有命名空间的单实例进程,03-Singleton</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[windows via c/c++ 笔记 （一）]]></title>
    <link href="http://airpfei.github.com/blog/2011/11/10/learn-windows-progamme-1/"/>
    <updated>2011-11-10T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/11/10/learn-windows-progamme-1</id>
    <content type="html"><![CDATA[<h2>第1章：错误处理</h2>


<p><span style="display:block;text-indent:2em;">调用GetLastError() 查看错误信息；</span>
<span style="display:block;text-indent:2em;">$err,hr 在watch窗口查看错误信息</span></p>

<h2>第2章：字符和字符串的处理</h2>


<p><span style="display:block;text-indent:2em;">字符串前的“L”告诉编译器该字符串为Unicode字符串；</span>
<span style="display:block;text-indent:2em;">windows内部由Unicode字符构建，优先使用Unicode编码；</span>
<span style="display:block;text-indent:2em;">CreateWindowExW (wide)接受Unicode编码，CreateWindowExA接受ANSI编码</span>
<span style="display:block;text-indent:2em;">使用CompareStringOrdinal、CompareString(Ex)比较字符串；</span>
<span style="display:block;text-indent:2em;">使用MultiByteToWideChar、WideCharToMultiByte进行Unicode、ANSI编码转换</span></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTC Desire s (G12) ROOT]]></title>
    <link href="http://airpfei.github.com/blog/2011/08/23/root-g12/"/>
    <updated>2011-08-23T00:00:00+08:00</updated>
    <id>http://airpfei.github.com/blog/2011/08/23/root-g12</id>
    <content type="html"><![CDATA[<p>0、将<a href="http://lossbot.com/file/su-2.3.6.3-efgh-signed.zip">su-2.3.6.3-efgh-signed.zip</a>拷贝到手机sd卡中；</p>

<p>1、从<a href="http://revolutionary.io/" target="_blank">http://revolutionary.io/</a> 下载Revolutionary，也可以从<a title="Revolutionary" href="http://lossbot.com/file/revolutionary-0.4pre4.zip" target="_blank">这里下载</a>；</p>

<p>2、<a title="adb" href="http://lossbot.com/file/adb.rar" target="_blank">下载ADB</a>(android sdk中的)，同时确保手机上的USB调试(Debug USB)开关打开，手机连接模式为“只充电”；</p>

<p>3、<a title="fre3vo" href="http://lossbot.com/file/fre3vo.zip" target="_blank">下载fre3vo</a>；</p>

<p>开始root</p>

<!--more-->


<p>1）在cmd中输入：adb push fre3vo /data/local/tmp                     （adb为第二步中下载的文件解压后）</p>

<p>2）adb shell chmod 777 /data/local/tmp/fre3vo</p>

<p>3）adb shell  （这时cmd中出现$符号，证明还没有得到root权限）</p>

<p>4）继续3，输入/data/local/tmp/fre3vo -debug -start FAA90000 -end FFFFFFFF  （这时将从$符号中跳出来）</p>

<p>5）adb shell  （这时将出现#，证明root成功）</p>

<p>4）运行第一步下载的revolutionary.exe会生成一个序列号，到<a href="http://revolutionary.io/">http://revolutionary.io/</a>上获取code；</p>

<p>5）完成上一步后手机会重启，进入revolutionary模式，选择第0步下载的文件，可以安装root权限的工具，当然这时也可以开始刷rom了，推荐miui的rom(<a href="http://www.miui.com/forum.php?mod=viewthread&amp;tid=4437&amp;page=1">http://www.miui.com/forum.php?mod=viewthread&amp;tid=4437&amp;page=1</a>)</p>

<p>。。。。。。</p>

<p>revolutionary模式进入方法是，先拔电池，音量下 + 电源键 长按就可以进入</p>
]]></content>
  </entry>
  
</feed>
